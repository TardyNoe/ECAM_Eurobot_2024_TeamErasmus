import cv2
import numpy as np
import heapq

# Define a class to represent a node in the grid
class Node:
    def __init__(self, position, parent=None):
        self.position = position
        self.parent = parent
        self.g = 0  # Cost from start node to this node
        self.h = 0  # Heuristic (estimated cost from this node to goal)
        self.f = 0  # Total cost (g + h)

    def __lt__(self, other):
        return self.f < other.f

# A* algorithm implementation
def astar(grid, start, end):
    open_list = []
    closed_set = set()

    start_node = Node(start)
    end_node = Node(end)

    heapq.heappush(open_list, start_node)

    while open_list:
        current_node = heapq.heappop(open_list)
        closed_set.add(current_node.position)

        # If the current node is the goal, reconstruct the path and return it
        if current_node.position == end_node.position:
            path = []
            while current_node:
                path.append(current_node.position)
                current_node = current_node.parent
            return path[::-1]  # Reverse the path before returning

        # Generate neighboring nodes
        neighbors = []
        for i in range(-1, 2):
            for j in range(-1, 2):
                if i == 0 and j == 0:
                    continue
                neighbor_pos = (current_node.position[0] + i, current_node.position[1] + j)
                if 0 <= neighbor_pos[0] < grid.shape[0] and 0 <= neighbor_pos[1] < grid.shape[1] and grid[neighbor_pos] != 255:
                    neighbors.append(neighbor_pos)

        for neighbor_pos in neighbors:
            if neighbor_pos in closed_set:
                continue

            neighbor_node = Node(neighbor_pos, parent=current_node)
            neighbor_node.g = current_node.g + 1
            neighbor_node.h = abs(neighbor_node.position[0] - end_node.position[0]) + abs(
                neighbor_node.position[1] - end_node.position[1]
            )
            neighbor_node.f = neighbor_node.g + neighbor_node.h

            # If the neighbor is not in the open list, add it
            if neighbor_node not in open_list:
                heapq.heappush(open_list, neighbor_node)
            # If the neighbor is already in the open list and has a higher cost, skip it
            elif neighbor_node.g >= current_node.g:
                continue

# Example usage
if __name__ == "__main__":
    # Load the mask (assuming it's a binary image where 255 represents walls)
    #mask = cv2.imread("mask.png", cv2.IMREAD_GRAYSCALE)``
    reftable = cv2.imread("/Users/noe/Downloads/table.png", 1)
    reftable = cv2.resize(reftable, (200,300), interpolation = cv2.INTER_AREA)

    #while True:
        #mask = cv2.imread("mask", 0)
    mask = np.zeros((300, 200), dtype=np.uint8)
    mask = cv2.circle(mask, (mask.shape[1] // 2, mask.shape[0] // 2), 50, 255, -1)
    mask1 = cv2.dilate(mask, np.ones((5, 5), np.uint8) , iterations=2) 


        #mask = cv2.cvtColor(mask, cv2.COLOR_GRAY2BGR)
    reftable[mask==255] = (36,255,12)
        # Define start and end points (in pixels)
    start_point = (10, 10)
    end_point = (290, 190)

        # Find the path using A*
    path = astar(mask1, start_point, end_point)

        # Visualize the path
    path_color = (0, 0, 255)  # Red color for the path
    for point in path:
        reftable[point] = path_color
    cv2.imshow("path",reftable)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
        # reftable is the output 
        #print("ok")
